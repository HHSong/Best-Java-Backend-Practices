# Creational Patterns
> Often, designs start out using Factory Method (less complicated, more customizable, subclasses proliferate) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, more complex) as the designer discovers where more flexibility is needed. - sourcemaking.com

#### 1. Builder
Builder pattern aims to construct objects in a most customizable way (in contrast to factory pattern). The attributes of the objects are indirectly set through the builder class which controls the flow. This sounds abstract so let look at some codes:

```java
public class AdvertisementBuilder {
  private Advertisement ad;
  public AdvertisementBuilder() {
    ad = new Advertisement();
  }

  public AdvertisementBuilder setTitle(String title) {
    ad.setTitle(title);
    return this;
  }

  public AdvertisementBuilder setCompany(Company company) {
    ad.setCompany(company);
    return this;
  }

  public AdvertisementBuilder setDuration(double duration) {
    ad.setDuration(duration);
    return this;
  }

  public AdvertisementBuilder setUrl(Url url) {
    ad.setUrl(url);
    return this;
  }

  // more setters

  public Advertisement build() {
    return ad;
  }

}

public class Advertisement {
  private String title;
  private Company owner;
  private double duration;
  private Url link;
  // more fields

  Advertisement() {} // different variations may have builder class as an inner class of the advertisement class

  // setters and getters
}

```

The codes look long and tedious. And yes they are. But we gain the advantage of controlling the flow of building the objects. A more complicated flow control could be done using different inner classes to expose certain fields before/after other fields. Some variation may have the duplicate fields in the builder class as well and initialize the Advertisement object when callign build() function.
Another advantage of this is to build a functional style of object creation: through a chain of function calls. It makes code a bit more readable and cleaner.
```java
Advertisement ad = new AdvertisementBuilder()
  .setTitle("title")
  .setDuration(1000)
  // more
  .build();
```
Comparing that to traditional setters:
```java
Advertisement ad = new Advertisement();
ad.setTitle("title");
ad.setDuration(1000);
// more
```
A common example can been seen in JAX-RS when building an http response or building Mybatis autogenerated queries.

#### 2. Factory Method & Abstract Factory
The two patterns seemingly the same and hard to discern the difference. Often time we see one's shadow in the other. 
So, what's the difference?

- Factory Method
Factory method generally is referred to some sort of operating system examples where a button is created differently on Mac OS and Windows. From the point of view of the client, which is a application programmer, all he wants is just to have buttons (plural! It doesn't make sense to create a bunch of class just to create one single button throughout the program. It's an over-design). Thus, naturally, we have an interface that defines create() function and let the client calls it and have MacOSImpl and WindowsImpl implements the interface and the method. This is it!

- Abstract Factory
Abstract factory is intented for creating a bunch of related objects. Imagine you are IKEA and you want to create a lot of kitchen utensils. You may have spoons, forks and knifes as different kinds. Also, you want silver, stanless steel, bamboo and plastic for all kinds of customers, cause you're greedy. So what do you do? 3 * 4 = 12. Creating 12 different functions in a class named factory? Maybe not, because you figure at some point there would be too many function so that you want to break it down to multiple ones. So you think of spoon factory, fork factory and knife factory each defines it's own way of making instances out of the same 4 materials. On the other hand, there could be 4 factories each making spoons, forks and knives. So which is better? Well, I guess that depends how you envision functions should be grouped and what can be achieved through inheritance and what can be done via composition. There is definitely mistakes and bad judgements so that later on when the code doesn't meet the requirements, we introduce more pattern bridging or adapting the existing ones.

- Difference
The patterns are not mutually exclusive. You may, in or abstract factories, use a factory method for each implementation detail. Any case, it is more of a question of dimensions. Factory method varies in one demension where there is one variable, could be the platform. On the other hand, Abstract factory hands two-demensional problems. Higher demensions maybe achieved with further abstraction but I guess that suddenly makes code so much harder to understand and maintain. Deep down, it is a conscious descision of maintainibility and leveraging patterns.


#### 3. Prototype (clone over new)
- Motive
The key concept of prototyping is to clone. By implementing the Cloneable interface, "new" action happens internally and all the setup, depending on implementation, would be cloned to the newly initiated object. 
```java
public interface Prototype extends Clonable {

}

public class InternalProduct implements Clonable {
  @Override
  public Object clone() {
    // some heavy copy implementation
  }
}

public class ExternalProduct implements Clonable {
  @Override
  public Object clone() {
    // some heavy copy implementation
  }
}

public class SomeClientClass {
  public void someMethod() {
    // exisitingInternalPrototype is previously built or passed in as argument
    doSomethingInternal(
      exisitingInternalPrototype.clone()
    );
  }
}

```

- vs Factory Method
I would imagine the difining line between Factory Method and Prototype is where you want to start with. Do you always want to start with the same set of values for an object or do you want the flexibility to start from a variation? I think with that in mind, the answer is clear:)

- Registry Enhancement
Additionally, I have seen examples where a registry is leveraged along side prototyping. Basically, there is a Manager/Registry class with most-likely static map of the prototypes. Whenever needed, the specific prototype is retrieved and cloned. 
```java
public class PrototypeRegistry {
  // could be Enum or String depending on the need
  final private static Map<PrototypeEnum, Prototype> prototypeMap;
  static {
    prototypeMap = new HashMap<>();
  }

  public static void register(PrototypeEnum prototypeEnum, Prototype prototype) {
    prototypeMap.push(prototypeEnum, prototype);
  }

  public static Prototype create(PrototypeEnum prototypeEnum) {
    return (Prototype) prototypeMap.get(prototypeEnum);
  }
}

```

Registry is especially useful when you want to inistialize a generic class where the exact type would be determined at run time. This case, all you need is to new the specific type once and register it so that later on when required, it could be cloned. 
(Remember that it is impossible to initialize an instance of the generic class without explicitly passing a Class object as argument.)

4. Pool and Singleton
Some objects are so lightweight that they are disposable and people tend to create them on the fly whenever needed. However, there are some objects that are costly to create, e.g. connections, threads, and so forth. Thus, the intuition is to minimize the creation. 

And that is why we have pools and singletons. These two are pretty straighforward. One is to create a fixed number of objects and register them in a place. Whoever needs an instance make a request to the registry. Examples could be found in thread pooling, connection pooling, log managers.

On the other hand, some class is well-designed that only one instance is ever needed throughout the lifetime. That is where the singleton pattern comes into play. Many dependency injection frameworks default the creation of objects to be singleton. Also, typical web services aiming to process numerous concurrent requests are designed to be stateless so that no contention would happen and therefore a singleton service object would suffice.

For singleton, there are quite a few strategies to create them. The main concern is whether to create them eagerly or lazily. For eager decision, enum and static are natural option and involve almost no complexity. As for lazy-initialization, it could be as simple as just check if there is an instance already created. 
```java
public class Target {
  private Target target = null;

  public static Target getInstance() {
    if (target == null)
      target = new Target();
    return target;
  }
}

```
The only concern about this code is concurrency. (What?! I thought that's why we want a singleton patter!) Yeah, sadly, imagine multiple threads happen to be within the if block that multiple instances are still created. Worse of all, each may hold a different instance.

So what do we do? Hold a lock and create it!
```java
public class Target {
  private Target target = null;

  public synchronized static Target getInstance() {
    if (target == null)
      target = new Target();
    return target;
  }
}

```
Well, that's good but maybe a bit slow since all requests using the class are blocked until it is finished. So, what now?
```java
public class Target {
  private Target target = null;

  public static Target getInstance() {
    if (target == null) {
      // recall that you hold the lock on the class instead of an object when it is static
      synchronized(Target.class) {
        target = new Target();
      }
    }
    return target;
  }
}

```
That looks more like it, right? I mean, right?
Not really, again, imagine all request goes within if block concurrently. Now even though it is synchronized, every requests would line up and create an instance one after another.
```java
public class Target {
  private volatile Target target = null; // volatile makes the change visible to other threads

  public static Target getInstance() {
    if (target == null) {
      synchronized(Target.class) {
        if (target == null)
          target = new Target();
      }
    }
    return target;
  }
}

```
This technique is called double-check locking. There could be also final touch on performance by introducing one more local variable. 
```java
public class Target {
  private volatile Target target = null; // volatile makes the change visible to other threads

  public static Target getInstance() {
    Target result = target;
    if (result == null) {
      synchronized(Target.class) {
        if (target == null)
          result = target = new Target();
      }
    }
    return target;
  }
}

```
> Note the local variable result, which seems unnecessary. The effect of this is that in cases where helper is already initialized (i.e., most of the time), the volatile field is only accessed once (due to "return result;" instead of "return helper;"), which can improve the method's overall performance by as much as 25 percent. - https://en.wikipedia.org/wiki/Double-checked_locking

Personally, I think this problem has widedly addressed and solved. It is good to know but probably somewhat impractical to actually implement it in the code. There are more sophisticated solutions by using already invented wheels:
1. inner class helper https://stackoverflow.com/a/16542487
2. java 8 lambda helper https://stackoverflow.com/a/29133244
3. Apache common lang LazyInitializer

Or even, simply just consider early initialization like Spring depency injection does.