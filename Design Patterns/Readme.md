# Design Patterns
 -- by Hao Hsiang Song

"There is nothing new under the sun." That explains the existence of design patterns. Every new features or problems could be decomposed into one or more commonly seen problems. And the solutions to them are well known the programmers' world.

---

## Creational Patterns
> Often, designs start out using Factory Method (less complicated, more customizable, subclasses proliferate) and evolve toward Abstract Factory, Prototype, or Builder (more flexible, more complex) as the designer discovers where more flexibility is needed.
-- sourcemaking.com

#### 1. Builder
Builder pattern aims to construct objects in a most customizable way (in contrast to factory pattern). The attributes of the objects are indirectly set through the builder class which controls the flow. This sounds abstract so let look at some codes:

```java
public class AdvertisementBuilder {
  private Advertisement ad;
  public AdvertisementBuilder() {
    ad = new Advertisement();
  }

  public AdvertisementBuilder setTitle(String title) {
    ad.setTitle(title);
    return this;
  }

  public AdvertisementBuilder setCompany(Company company) {
    ad.setCompany(company);
    return this;
  }

  public AdvertisementBuilder setDuration(double duration) {
    ad.setDuration(duration);
    return this;
  }

  public AdvertisementBuilder setUrl(Url url) {
    ad.setUrl(url);
    return this;
  }

  // more setters

  public Advertisement build() {
    return ad;
  }

}

public class Advertisement {
  private String title;
  private Company owner;
  private double duration;
  private Url link;
  // more fields

  Advertisement() {} // different variations may have builder class as an inner class of the advertisement class

  // setters and getters
}

```

The codes look long and tedious. And yes they are. But we gain the advantage of controlling the flow of building the objects. A more complicated flow control could be done using different inner classes to expose certain fields before/after other fields. Some variation may have the duplicate fields in the builder class as well and initialize the Advertisement object when callign build() function.
Another advantage of this is to build a functional style of object creation: through a chain of function calls. It makes code a bit more readable and cleaner.
```java
Advertisement ad = new AdvertisementBuilder()
  .setTitle("title")
  .setDuration(1000)
  // more
  .build();
```
Comparing that to traditional setters:
```java
Advertisement ad = new Advertisement();
ad.setTitle("title");
ad.setDuration(1000);
// more
```
A common example can been seen in JAX-RS when building an http response or building Mybatis autogenerated queries.

#### 2. Factory Method & Abstract Factory
The two patterns seemingly the same and hard to discern the difference. Often time we see one's shadow in the other. 
So, what's the difference?

- Factory Method
Factory method generally is referred to some sort of operating system examples where a button is created differently on Mac OS and Windows. From the point of view of the client, which is a application programmer, all he wants is just to have buttons (plural! It doesn't make sense to create a bunch of class just to create one single button throughout the program. It's an over-design). Thus, naturally, we have an interface that defines create() function and let the client calls it and have MacOSImpl and WindowsImpl implements the interface and the method. This is it!

- Abstract Factory
Abstract factory is intented for creating a bunch of related objects. Imagine you are IKEA and you want to create a lot of kitchen utensils. You may have spoons, forks and knifes as different kinds. Also, you want silver, stanless steel, bamboo and plastic for all kinds of customers, cause you're greedy. So what do you do? 3 * 4 = 12. Creating 12 different functions in a class named factory? Maybe not, because you figure at some point there would be too many function so that you want to break it down to multiple ones. So you think of spoon factory, fork factory and knife factory each defines it's own way of making instances out of the same 4 materials. On the other hand, there could be 4 factories each making spoons, forks and knives. So which is better? Well, I guess that depends how you envision functions should be grouped and what can be achieved through inheritance and what can be done via composition. There is definitely mistakes and bad judgements so that later on when the code doesn't meet the requirements, we introduce more pattern bridging or adapting the existing ones.

- Difference
The patterns are not mutually exclusive. You may, in or abstract factories, use a factory method for each implementation detail. Any case, it is more of a question of dimensions. Factory method varies in one demension where there is one variable, could be the platform. On the other hand, Abstract factory hands two-demensional problems. Higher demensions maybe achieved with further abstraction but I guess that suddenly makes code so much harder to understand and maintain. Deep down, it is a conscious descision of maintainibility and leveraging patterns.


#### 3. Prototype (clone over new)
- Motive
The key concept of prototyping is to clone. By implementing the Clonable interface, "new" action happens internally and all the setup, depending on implementation, would be cloned to the newly initiated object. 

- vs Factory Method
I would imagine the difining line between Factory Method and Prototype is where you want to start with. Do you always want to start with the same set of values for an object or do you want the flexibility to start from a variation? I think with that in mind, the answer is clear:)

- Registry Enhancement
Additionally, I have seen examples where a registry is leveraged along side prototyping. Basically, there is a Manager/Registry class with most-likely static map of the prototypes. Whenever needed, the specific prototype is retrieved and cloned. 




